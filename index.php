<?php
    // index.php — примітивний роутер для декількох сторінок

    // -------------------------------
    //  Налаштування маршрутів у вигляді асоціативного масиву
    //  Ключ — URL-шлях; значення — заголовок і файл у /pages
    // -------------------------------
    $routes = [
        "/"       => ["title" => "ГОЛОВНА",     "file" => "home.php"],
        "/page1"  => ["title" => "СТОРІНКА 1",  "file" => "page1.php"],
        "/page2"  => ["title" => "СТОРІНКА 2",  "file" => "page2.php"],
        "/page3"  => ["title" => "СТОРІНКА 3",  "file" => "page3.php"],
    ];

    // -------------------------------
    //  Далі ми отримуємо значення URI - це те, що клієнт вводить в браузері
    //  Наприклад, клієнт ввів http://localhost:80/page1
    //  Значить URI буде "/page1", збережемо це в змінну $path
    // -------------------------------
    
    $path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH);
    // Пояснення попереднього рядку:
    // $_SERVER['REQUEST_URI'] - Це глобальна змінна PHP, у якій лежить повний URI, який користувач ввів у браузері після домену.
    // ?? '/' - Це оператор null-coalescing (“якщо немає значення — використай інше”).
    // Якщо з якоїсь причини $_SERVER['REQUEST_URI'] відсутня або null, тоді у змінну підставиться '/'
    // parse_url(..., PHP_URL_PATH) - Функція parse_url вміє розбивати URL на частини 
    // Якщо вказати другим параметром PHP_URL_PATH, вона поверне тільки шлях (path) без параметрів.
    // Отже, навіть якщо в браузері ми введемо адресу разом з GET параметрами, то в змінну $path всеодно запишеться лише URI
    // Приклад: http://localhost:80/page1?param1=value1&param2=value2
    // Тут окрім URI є ще 2 параметри: param1=value1, param2=value2
    // Але в змінну $path запишеться лише "page1"
    
    if ($path === null || $path === false) {
        $path = '/';
    }

    // -------------------------------
    // 3) Нормалізація слешів
    //    - забираємо кінцевий "/" (крім кореня)
    //    - порожній шлях трактуємо як "/"
    // -------------------------------
    $path = rtrim($path, '/');
    if ($path === '') {
        $path = '/';
    }
    // Код вище робить дуже просту річ — страховку від помилок.
    
    // -------------------------------
    // Тепер маємо змінну $path, виконуємо пошук маршруту і підключення файлу
    // -------------------------------
    // Використаємо пошук в масиві по ключу, функція array_key_exists()
    if (array_key_exists($path, $routes)) {
        // $routes[$path]['title'] - Беремо з масиву $routes елемент з ключем $path
        // ?? 'Сторінка' - якщо ліва частина (тут $routes[$path]['title']) існує і не є null, то береться її значення;
        // інакше використовується значення справа ('Сторінка')
        $title = $routes[$path]['title'] ?? 'Сторінка';
        
        // __DIR__ - магічна константа в PHP, повертає повний шлях до директорії, де лежить поточний файл
        // DIRECTORY_SEPARATOR - вбудована константа PHP, яка залежить від ОС 
        // у Linux / macOS → '/'
        // у Windows → '\'
        $file = __DIR__ . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . $routes[$path]['file'];
    
        // Перевірка існування файлу
        if (is_file($file)) {
            $currentPath = $path;
            include $file;
            exit;
        } else {
            // Це на випадок, якщо у нас не існує файлу сторінки
            http_response_code(500);
            $file500 = __DIR__ . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . '500.php';
            include $file404;
            exit;
        }
    }

    // -------------------------------
    // Будуємо сторінку 404: маршруту немає
    // -------------------------------
    http_response_code(404);
    $title = "Сторінка не знайдена";
    $file404 = __DIR__ . '/pages/404.php';
    if (is_file($file404)) {
        include $file404;
    } else {
        // Запасний варіант, якщо ще не створено pages/404.php
        echo "<h1>404</h1><p>Сторінку не знайдено.</p>";
    }